import json
import hashlib
import math
from pwn import *
from Crypto.Cipher import AES
from sympy.ntheory.modular import crt

HOST = 'localhost'
PORT = 4444
TARGET_BITS = 1024

factors= [2, 3, 23, 107, 113, 127, 131, 149, 151, 157, 167, 193, 229, 241, 257, 263, 311, 317, 359, 409, 421, 443, 457, 463, 467, 571, 587, 593, 653, 661, 677, 709, 739, 743, 751, 773, 829, 857, 863, 887, 907, 911, 977, 1009, 1033, 1039, 1129, 1151, 1163, 1181, 1229, 1279, 1289, 1307, 1319, 1327, 1367, 1373, 1423, 1447, 1451, 1511, 1523, 1553, 1571, 1579, 1613, 1619, 1637, 1657, 1667, 1669, 1697, 1699, 1709, 1741, 1747, 1777, 1861, 1871, 1879, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1997, 1999, 2017, 2029, 2039, 2063, 2089, 2099, 2131, 2141, 2143, 2161, 2179, 2267, 2273, 2287, 2293, 2333, 2339, 2351, 2357, 2371, 2383, 2393, 2423, 2447, 2459, 2467, 2473, 2521, 2543, 2549, 2557, 2593, 2617, 2659, 2663, 2683, 2741, 2753, 2953, 2957, 2963, 3019, 3061, 3067, 3169, 3181, 3187, 3221, 3271, 3307, 3329, 3347, 3373, 3389, 3391, 3467, 3499, 3527, 3583, 3617, 3623, 3631, 3637, 3677, 3709, 3761, 3769, 3917, 3931, 3943, 4013, 4091, 4127, 4157, 4159, 4201, 4211, 4217, 4327, 4349, 4397, 4493, 4513, 4523, 4547, 4567, 4621, 4637, 4663, 4679, 4721, 4729, 4861, 4871, 4877, 4931, 4937, 4957, 4969, 4993, 7951, 308117]

moduli = []
remainders = []
current_bits = 0

print(f"[*] Starting attack")
io = remote(HOST, PORT)
traffic = io.recvline_contains(b"Payload: ").decode()
intercepted = json.loads(traffic.split("Payload: ")[1])
io.close()

# Get p and bob public key
io = remote(HOST, PORT)
io.sendlineafter(b"> ", b"2")
io.recvuntil(b"Bob PubKey: ")
bob_pub = int(io.recvline().decode().strip())
p = int(io.recvline_contains(b"p: ").decode().split(": ")[1])
io.close()

print(f"[*] Starting subgroup injection...")

for q in factors:
    if current_bits >= TARGET_BITS:
        print("[!] Threshold reached. Ready for CRT.")
        break
    
    try:
        r = remote(HOST, PORT)
        r.sendlineafter(b"> ", b"1")
        
        # craft rogue public key
        X = pow(2, (p - 1) // q, p)
        r.sendlineafter(b"Your Key: ", str(X).encode())
        
        # Get Alice public key
        resp_raw = r.recvline_contains(b"Alice: ").decode()
        res = json.loads(resp_raw.split("Alice: ")[1])
        r.close()
        # get aes encryption info
        iv = bytes.fromhex(res['iv'])
        ct = bytes.fromhex(res['ciphertext'])
        tag = bytes.fromhex(res['tag'])

        #guessing the remainder
        for i in range(q):
            secret_guess = pow(X, i, p)
            key = hashlib.sha256(str(secret_guess).encode()).digest()
            cipher = AES.new(key, AES.MODE_GCM, nonce=iv)
            try:
                # if tag is valid store q and the remainder
                cipher.decrypt_and_verify(ct, tag)
                remainders.append(i)
                moduli.append(q)
                current_bits = sum(math.log2(m) for m in moduli)  # informations brought by q 
                print(f"[+] Found mod {q:4} | Bits: {current_bits:4.1f}/{TARGET_BITS}")
                break
            except:
                continue
    except Exception as e:
        print(f"[-] Skip {q}: {e}")

print("\n[*] Reconstructing Alice's Private Key...")
alice_priv = crt(moduli, remainders)[0] # CRT with r_i and q_i to retreive a 

# shared = Bob_pub ^ Alice_priv mod p
shared_secret = pow(bob_pub, int(alice_priv), p)

# Flag
key_final = hashlib.sha256(str(shared_secret).encode()).digest()
cipher_final = AES.new(key_final, AES.MODE_GCM, nonce=bytes.fromhex(intercepted['iv']))
flag = cipher_final.decrypt_and_verify(bytes.fromhex(intercepted['ciphertext']), bytes.fromhex(intercepted['tag']))

print(f"\n[!] SUCCESS: {flag.decode()}")
